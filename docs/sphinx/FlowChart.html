

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Flowchart &mdash; Castro 18.11
 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Software Design" href="software.html" />
    <link rel="prev" title="namespace: castro" href="runtime_parameters.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index_docs.html" class="icon icon-home"> Castro
          

          
          </a>

          
            
            
              <div class="version">
                18.11

              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Castro basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Flowchart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-a-single-step-no-sdc">Overview of a single step (no SDC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-hydro-reaction-and-gravity-advancement-ctu-w-strang-splitting">Main Hydro, Reaction, and Gravity Advancement (CTU w/ Strang-splitting)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#main-hydro-reaction-and-gravity-advancement-mol-w-strang-splitting">Main Hydro, Reaction, and Gravity Advancement (MOL w/ Strang-splitting)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-a-single-step-with-sdc">Overview of a single step (with SDC)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-hydro-and-gravity-advancement-sdc">Main Hydro and Gravity Advancement (SDC)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="software.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_a_problem.html">Setting Up Your Own Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Parallel I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">Castro reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="coding_conventions.html">Coding Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="gravity.html">Gravity</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOSNetwork.html">Microphysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMR.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
<li class="toctree-l1"><a class="reference internal" href="namespacelist.html">Namespace list</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index_docs.html">Castro</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index_docs.html">Docs</a> &raquo;</li>
        
      <li>Flowchart</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/FlowChart.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="flowchart">
<h1>Flowchart<a class="headerlink" href="#flowchart" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>There are several different time-evolution methods currently
implemented in Castro. As best as possible, they share the same
driver routines and use preprocessor or runtime variables to separate
the different code paths.</p>
<ul class="simple">
<li>Strang-splitting: the Strang evolution does the burning on the
state for <span class="math notranslate nohighlight">\(\Delta t/2\)</span>, then updates the hydrodynamics using the
burned state, and then does the final <span class="math notranslate nohighlight">\(\Delta t/2\)</span> burning. No
explicit coupling of the burning and hydro is done. Within the
Strang code path, there are two methods for doing the hydrodynamics,
controlled by castro.do_ctu.<ul>
<li>Corner-transport upwind (CTU): this implements the unsplit,
characteristic tracing method of <a class="reference internal" href="references.html#colella-1990" id="id1">[Colella90]</a>.</li>
<li>Method of lines (MOL): this discretizes the space part of
our system without any characteristic tracing and uses an
ODE integrator to advance the state. Multiple stages can be done,
each requiring reconstruction, Riemann solve, etc., and the final
solution is pieced together from the intermediate stages.</li>
</ul>
</li>
<li>SDC: the SDC path is enabled by the SDC preprocessor
variable. This iteratively couples the reactions and hydrodynamics together.</li>
</ul>
<p>Several helper functions are used throughout:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">clean_state</span></code>:
There are many ways that the hydrodynamics state may become
unphysical in the evolution. The <code class="docutils literal notranslate"><span class="pre">clean_state()</span></code> routine
enforces some checks on the state. In particular, it<ol class="arabic">
<li>enforces that the density is above <code class="docutils literal notranslate"><span class="pre">castro.small_dens</span></code></li>
<li>normalizes the species so that the mass fractions sum to 1</li>
<li>resets the internal energy if necessary (too small or negative)
and computes the temperature for all zones to be thermodynamically
consistent with the state.</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="overview-of-a-single-step-no-sdc">
<span id="flow-sec-nosdc"></span><h2>Overview of a single step (no SDC)<a class="headerlink" href="#overview-of-a-single-step-no-sdc" title="Permalink to this headline">¶</a></h2>
<p>The main evolution for a single step is contained in
<code class="docutils literal notranslate"><span class="pre">Castro_advance.cpp</span></code>, as <code class="docutils literal notranslate"><span class="pre">Castro::advance()</span></code>. This does
the following advancement. Note, some parts of this are only done
depending on which preprocessor directives are defined at
compile-time—the relevant directive is noted in the [&nbsp;] at the start
of each step.</p>
<ol class="arabic">
<li><p class="first"><em>Initialization</em> (<code class="docutils literal notranslate"><span class="pre">initialize_advance()</span></code>)</p>
<p>This sets up the current level for advancement. The following
actions are performend (note, we omit the actions taken for a retry,
which we will describe later):</p>
<ul class="simple">
<li>Sync up the level information to the Fortran-side of Castro</li>
<li>Do any radiation initialization</li>
<li>Initialize all of the intermediate storage arrays (like those
that hold source terms, etc.).</li>
<li>Swap the StateData from the new to old (e.g., ensures that
the next evolution starts with the result from the previous step).</li>
<li>Do a <code class="docutils literal notranslate"><span class="pre">clean_state</span></code></li>
<li>Create the MultiFabs that hold the primitive variable information
for the hydro solve.</li>
<li>For method of lines integration: allocate the storage for the
intermediate stage updates, <code class="docutils literal notranslate"><span class="pre">k_mol</span></code>, and the <code class="docutils literal notranslate"><span class="pre">Sburn</span></code>
MultiFab&nbsp;that holds the post burn state.</li>
<li>Zero out all of the fluxes</li>
</ul>
</li>
<li><p class="first"><em>Advancement</em></p>
<p>The update strategy differs for CTU vs MOL:</p>
<ul class="simple">
<li>CTU: Calls <code class="docutils literal notranslate"><span class="pre">do_advance</span> <span class="pre">to</span></code> take a single step,
incorporating hydrodynamics, reactions, and source terms.</li>
<li>MOL: Call <code class="docutils literal notranslate"><span class="pre">do_advance_mol</span></code> <code class="docutils literal notranslate"><span class="pre">MOL_STAGES</span></code> times
(i.e., once for each of the intermediate stages in the ODE
integration). Within <code class="docutils literal notranslate"><span class="pre">do_advance</span></code> we will use the stage
number, <code class="docutils literal notranslate"><span class="pre">mol_iteration</span></code>, to do an pre- or post-hydro
sources (e.g., burning).</li>
</ul>
<p>In either case, for radiation-hydrodynamics, this step does the
advective (hyperbolic) portion of the radiation update only.
Source terms, including gravity, rotation, and diffusion are
included in this step, and are time-centered to achieve second-order
accuracy.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">castro.use_retry</span></code> is set, then we subcycle the current
step if we violated any stability criteria to reach the desired
<span class="math notranslate nohighlight">\(\Delta t\)</span>. The idea is the following: if the timestep that you
took had a timestep that was not sufficient to enforce the stability
criteria that you would like to achieve, such as the CFL criterion
for hydrodynamics or the burning stability criterion for reactions,
you can retry the timestep by setting <code class="docutils literal notranslate"><span class="pre">castro.use_retry</span></code> = 1 in
your inputs file. This will save the current state data at the
beginning of the level advance, and then if the criteria are not
satisfied, will reject that advance and start over from the old
data, with a series of subcycled timesteps that should be small
enough to satisfy the criteria. Note that this will effectively
double the memory footprint on each level if you choose to use it.</p>
</li>
<li><p class="first">[AUX_UPDATE] <em>Auxiliary quantitiy evolution</em></p>
<p>Auxiliary variables in Castro are those that obey a continuity
equation (with optional sources) that are passed into the EOS, but
not subjected to the constraint on mass fractions (summing to one).</p>
<p>The advection and source terms are already dealt with in the
main hydrodynamics advance (above step). A user-supplied routine
ca_auxupdate can be provided here to further update these
quantities.</p>
</li>
<li><p class="first"><em>Radial data and [POINTMASS] point mass</em></p>
<p>If <code class="docutils literal notranslate"><span class="pre">castro.spherical_star</span></code> is set, then we average the state data
over angles here to create a radial profile. This is then used in the
boundary filling routines to properly set Dirichlet BCs when our domain
is smaller than the star, so the profile on the boundaries will not
be uniform.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">castro.point_mass_fix_solution</span></code> is set, then we
change the mass of the point mass that optionally contributes to the
gravitational potential by taking mass from the surrounding zones
(keeping the density in those zones constant).</p>
</li>
<li><p class="first">[RADIATION] <em>Radiation implicit update</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">do_advance()</span></code> routine only handled the hyperbolic
portion of the radiation update. This step does the implicit solve
(either gray or multigroup) to advance the radiation energies to the
new time level. Note that at the moment, this is backward-difference
implicit (first-order in time) for stability.</p>
<p>This is handled by <code class="docutils literal notranslate"><span class="pre">final_radiation_call()</span></code>.</p>
</li>
<li><p class="first">[PARTICLES] <em>Particles</em></p>
<p>If we are including passively-advected particles, they are
advanced in this step.</p>
</li>
<li><p class="first"><em>Finalize</em></p>
<p>This cleans up at the end of a step:</p>
<ul class="simple">
<li>Update the flux registers to account for mismatches at
coarse-fine interfaces. This cleans up the memory used during
the step.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">castro.track_grid_losses</span></code> is set, then we
also add up the mass that left through the boundary over this
step. <a class="footnote-reference" href="#id6" id="id2">[1]</a></li>
<li>Free any memory allocated for the level advance.</li>
</ul>
</li>
</ol>
<div class="section" id="main-hydro-reaction-and-gravity-advancement-ctu-w-strang-splitting">
<h3>Main Hydro, Reaction, and Gravity Advancement (CTU w/ Strang-splitting)<a class="headerlink" href="#main-hydro-reaction-and-gravity-advancement-ctu-w-strang-splitting" title="Permalink to this headline">¶</a></h3>
<p>The explicit portion of the system advancement (reactions,
hydrodynamics, and gravity) is done by <code class="docutils literal notranslate"><span class="pre">do_advance()</span></code>. Consider
our system of equations as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial\Ub}{\partial t} = -{\bf A}(\Ub) + \Rb(\Ub) + \Sb,\]</div>
<p>where <span class="math notranslate nohighlight">\({\bf A}(\Ub) = \nabla \cdot \Fb(\Ub)\)</span>, with <span class="math notranslate nohighlight">\(\Fb\)</span> the flux vector, <span class="math notranslate nohighlight">\(\Rb\)</span> are the reaction
source terms, and <span class="math notranslate nohighlight">\(\Sb\)</span> are the non-reaction source terms, which
includes any user-defined external sources, <span class="math notranslate nohighlight">\(\Sb_{\rm ext}\)</span>. We use
Strang splitting to discretize the advection-reaction equations. In
summary, for each time step, we update the conservative variables,
<span class="math notranslate nohighlight">\(\Ub\)</span>, by reacting for half a time step, advecting for a full time
step (ignoring the reaction terms), and reacting for half a time step.
The treatment of source terms complicates this a little. The actual
update, in sequence, looks like:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\Ub^\star &amp;= \Ub^n + \frac{\dt}{2}\Rb(\Ub^n) \\
\Ub^{n+1,(a)} &amp;= \Ub^\star + \dt\, \Sb(\Ub^\star) \\
\Ub^{n+1,(b)} &amp;= \Ub^{n+1,(a)} - \dt\, {\bf A}(\Ub^\star) \\
\Ub^{n+1,(c)} &amp;= \Ub^{n+1,(b)} + \frac{\dt}{2}\, [\Sb(\Ub^{n+1,(b)}) - \Sb(\Ub^\star)] \label{eq:source_correct}\\
\Ub^{n+1}     &amp;= \Ub^{n+1,(c)} + \frac{\dt}{2} \Rb(\Ub^{n+1,(c)})\end{aligned}\end{split}\]</div>
<p>Note that in the first step, we add a full <span class="math notranslate nohighlight">\(\Delta t\)</span> of the old-time
source to the state. This prediction ensures consistency when it
comes time to predicting the new-time source at the end of the update.
The construction of the advective terms, <span class="math notranslate nohighlight">\({\bf A(\Ub)}\)</span> is purely
explicit, and based on an unsplit second-order Godunov method. We
predict the standard primitive variables, as well as <span class="math notranslate nohighlight">\(\rho e\)</span>, at
time-centered edges and use an approximate Riemann solver construct
fluxes.</p>
<p>At the beginning of the time step, we assume that <span class="math notranslate nohighlight">\(\Ub\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> are
defined consistently, i.e., <span class="math notranslate nohighlight">\(\rho^n\)</span> and <span class="math notranslate nohighlight">\(\phi^n\)</span> satisfy equation
(<a class="reference external" href="#eq:SelfGravity">[eq:Self Gravity]</a>). Note that in
Eq.&nbsp;<a class="reference external" href="#eq:source_correct">[eq:source_correct]</a>, we actually can actually do some
sources implicitly by updating density first, and then momentum,
and then energy. This is done for rotating and gravity, and can
make the update more akin to:</p>
<div class="math notranslate nohighlight">
\[\Ub^{n+1,(c)} = \Ub^{n+1,(b)} + \frac{\dt}{2} [\Sb(\Ub^{n+1,(c)}) - \Sb(\Ub^n)]\]</div>
<p>Castro&nbsp;also supports radiation. This part of the update algorithm
only deals with the advective / hyperbolic terms in the radiation update.</p>
<p>Here is the single-level algorithm. The goal here is to update the
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code>  StateData from the old to new time (see
§&nbsp;<a class="reference external" href="#soft:sec:statedata">[soft:sec:statedata]</a>). We will use the following notation
here, consistent with the names used in the code:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">S_old</span></code> is a MultiFab reference to the old-time-level
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data.</li>
<li><code class="docutils literal notranslate"><span class="pre">Sborder</span></code> is a MultiFab that has ghost cells and is
initialized from <code class="docutils literal notranslate"><span class="pre">S_old</span></code>. This is what the hydrodynamic
reconstruction will work from.</li>
<li><code class="docutils literal notranslate"><span class="pre">S_new</span></code> is a MultiFab reference to the new-time-level
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data.</li>
</ul>
<p>In the code, the objective is to evolve the state from the old time,
<code class="docutils literal notranslate"><span class="pre">S_old</span></code>, to the new time, <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<ol class="arabic">
<li><p class="first">[strang:init] <em>Initialize</em></p>
<ol class="arabic simple">
<li>In <code class="docutils literal notranslate"><span class="pre">initialize_do_advance()</span></code> :<ol class="arabic">
<li>Create <code class="docutils literal notranslate"><span class="pre">Sborder</span></code>, initialized from <code class="docutils literal notranslate"><span class="pre">S_old</span></code></li>
</ol>
</li>
<li>Check for NaNs in the initial state, <code class="docutils literal notranslate"><span class="pre">S_old</span></code>.</li>
</ol>
</li>
<li><p class="first"><em>React</em> <span class="math notranslate nohighlight">\(\Delta t/2\)</span> [<code class="docutils literal notranslate"><span class="pre">strang_react_first_half()</span></code> ]</p>
<p>Update the solution due to the effect of reactions over half a time
step. The integration method and system of equations used here is
determined by a host of runtime parameters that are part of the
Microphysics package. But the basic idea is to evolve the energy
release from the reactions, the species mass fractions, and
temperature through <span class="math notranslate nohighlight">\(\Delta t/2\)</span>.</p>
<p>Using the notation above, we begin with the time-level <span class="math notranslate nohighlight">\(n\)</span> state,
<span class="math notranslate nohighlight">\(\Ub^n\)</span>, and produce a state that has evolved only due to reactions,
<span class="math notranslate nohighlight">\(\Ub^\star\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    (\rho e)^\star &amp;= (\rho e)^\star - \frac{\dt}{2} \rho H_\mathrm{nuc} \\
    (\rho E)^\star &amp;= (\rho E)^\star - \frac{\dt}{2} \rho H_\mathrm{nuc} \\
    (\rho X_k)^\star &amp;= (\rho X_k)^\star + \frac{\dt}{2}(\rho\omegadot_k)^n.
  \end{aligned}\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(H_\mathrm{nuc}\)</span> is the energy release (erg/g/s) over the
burn, and <span class="math notranslate nohighlight">\(\omegadot_k\)</span> is the creation rate for species <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>After exiting the burner, we call the EOS with <span class="math notranslate nohighlight">\(\rho^\star\)</span>,
<span class="math notranslate nohighlight">\(e^\star\)</span>, and <span class="math notranslate nohighlight">\(X_k^\star\)</span> to get the new temperature, <span class="math notranslate nohighlight">\(T^\star\)</span>.</p>
<p>Note that the density, <span class="math notranslate nohighlight">\(\rho\)</span>, does not change via reactions in the
Strang-split formulation.</p>
<p>The reaction data needs to be valid in the ghost cells. The logic
in this routine (accomplished throuh the use of a mask) will burn
only in the valid interior cells or in any ghost cells that are on a
coarse-fine interface or physical boundary. This allows us to just
use a level <code class="docutils literal notranslate"><span class="pre">FillBoundary()</span></code> call to fill all of the ghost cells
on the same level with valid data.</p>
<p>An experimental option (enabled via
<code class="docutils literal notranslate"><span class="pre">use_custom_knapsack_weights</span></code>) will create a custom
distribution map based on the work needed in burning a zone and
redistribute the boxes across processors before burning, to better
load balance.</p>
<p>After reactions, <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> is called.</p>
<p>At the end of this step, <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> sees the effects of the
reactions.</p>
</li>
<li><p class="first">[strang:oldsource] <em>Construct time-level n sources and apply</em>
[<code class="docutils literal notranslate"><span class="pre">construct_old_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_old_sources()</span></code> ]</p>
<p>The time level <span class="math notranslate nohighlight">\(n\)</span> sources are computed, and added to the
StateData <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code>. The sources are then applied
to the state after the burn, <span class="math notranslate nohighlight">\(\Ub^\star\)</span> with a full <span class="math notranslate nohighlight">\(\Delta t\)</span>
weighting (this will be corrected later). This produces the
intermediate state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(a)}\)</span>.</p>
<p>The sources that we deal with here are:</p>
<ol class="arabic">
<li><p class="first">sponge : the sponge is a damping term added to
the momentum equation that is designed to drive the velocities to
zero over some timescale. Our implementation of the sponge
follows that of Maestro <a class="reference internal" href="references.html#maestro-iii" id="id3">[AlmgrenBellNonakaZingale08]</a></p>
</li>
<li><p class="first">external sources : users can define problem-specific sources
in the <code class="docutils literal notranslate"><span class="pre">ext_src_?d.f90</span></code> file. Sources for the different
equations in the conservative state vector, <span class="math notranslate nohighlight">\(\Ub\)</span>, are indexed
using the integer keys defined in <code class="docutils literal notranslate"><span class="pre">meth_params_module</span></code>
(e.g., URHO).</p>
<p>This is most commonly used for external heat sources (see the
<code class="docutils literal notranslate"><span class="pre">toy_convect</span></code> problem setup) for an example. But most
problems will not use this.</p>
</li>
<li><p class="first">[<code class="docutils literal notranslate"><span class="pre">DIFFUSION</span></code>] diffusion : thermal diffusion can be
added in an explicit formulation. Second-order accuracy is
achieved by averaging the time-level <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n+1\)</span> terms, using
the same predictor-corrector strategy described here.</p>
<p>Note: thermal diffusion is distinct from radiation hydrodynamics.</p>
<p>Also note that incorporating diffusion brings in an additional
timestep constraint, since the treatment is explicit. See
Chapter&nbsp;<a class="reference external" href="#ch:diffusion">[ch:diffusion]</a> for more details.</p>
</li>
<li><p class="first">[<code class="docutils literal notranslate"><span class="pre">HYBRID_MOMENTUM</span></code>] angular momentum</p>
</li>
<li><p class="first">[<code class="docutils literal notranslate"><span class="pre">GRAVITY</span></code>] gravity:</p>
<p>For full Poisson gravity, we solve for for gravity using:</p>
<div class="math notranslate nohighlight">
\[\gb^n = -\nabla\phi^n, \qquad
      \Delta\phi^n = 4\pi G\rho^n,\]</div>
<p>The construction of the form of the gravity source for the
momentum and energy equation is dependent on the parameter
<code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code>. Full details of the gravity
solver are given in Chapter&nbsp;<a class="reference external" href="#ch:gravity">[ch:gravity]</a>.</p>
</li>
<li><p class="first">[<code class="docutils literal notranslate"><span class="pre">ROTATION</span></code>] rotation</p>
<p>We compute the rotational potential (for use in the energy update)
and the rotational acceleration (for use in the momentum
equation). This includes the Coriolis and centrifugal terms in a
constant-angular-velocity co-rotating frame. The form of the
rotational source that is constructed then depends on the
parameter <code class="docutils literal notranslate"><span class="pre">castro.rot_source_type</span></code>. More details are
given in Chapter&nbsp;<a class="reference external" href="#ch:rotation">[ch:rotation]</a>.</p>
</li>
</ol>
<p>The source terms here are evaluated using the post-burn state,
<span class="math notranslate nohighlight">\(\Ub^\star\)</span> (<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>), and later corrected by using the
new state just before the burn, <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span>. This is compatible
with Strang-splitting, since the hydro and sources takes place
completely inside of the surrounding burn operations.</p>
<p>Note that the source terms are already applied to <code class="docutils literal notranslate"><span class="pre">S_new</span></code>
in this step, with a full <span class="math notranslate nohighlight">\(\Delta t\)</span>—this will be corrected later.</p>
</li>
<li><p class="first">[strang:hydro] <em>Construct the hydro update</em> [construct_hydro_source()]</p>
<p>The goal is to advance our system considering only the advective
terms (which in Cartesian coordinates can be written as the
divergence of a flux).</p>
<p>We do the hydro update in two parts—first we construct the
advective update and store it in the hydro_source
MultiFab, then we do the conservative update in a separate step. This
separation allows us to use the advective update separately in more
complex time-integration schemes.</p>
<p>In the Strang-split formulation, we start the reconstruction using
the state after burning, <span class="math notranslate nohighlight">\(\Ub^\star\)</span> (<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>). There
are two approaches we use, the corner transport upwind (CTU) method
that uses characteristic tracing as described in
<a class="reference internal" href="references.html#colella-1990" id="id4">[Colella90]</a>, and a method-of-lines approach. The choice is
determined by the parameter castro.do_ctu.</p>
<ol class="arabic">
<li><p class="first">CTU method:</p>
<p>For the CTU method, we predict to the half-time (<span class="math notranslate nohighlight">\(n+1/2\)</span>) to get a
second-order accurate method. Note: <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> does not
know of any sources except for reactions. The advection step is
complicated, and more detail is given in Section
<a class="reference external" href="#Sec:AdvectionStep">[Sec:Advection Step]</a>. Here is the summarized version:</p>
<ol class="arabic simple">
<li>Compute primitive variables.</li>
<li>Convert the source terms to those acting on primitive variables</li>
<li>Predict primitive variables to time-centered edges.</li>
<li>Solve the Riemann problem.</li>
<li>Compute fluxes and update.</li>
</ol>
<p>To start the hydrodynamics, we need to know the hydrodynamics source
terms at time-level <span class="math notranslate nohighlight">\(n\)</span>, since this enters into the prediction to
the interface states. This is essentially the same vector that was
computed in the previous step, with a few modifications. The most
important is that if we set
<code class="docutils literal notranslate"><span class="pre">castro.source_term_predictor</span></code>, then we extrapolate the
source terms from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(n+1/2\)</span>, using the change from the previous
step.</p>
<p>Note: we neglect the reaction source terms, since those are already
accounted for in the state directly, due to the Strang-splitting
nature of this method.</p>
<p>The update computed here is then immediately applied to
<code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</li>
<li><p class="first">method of lines</p>
</li>
</ol>
</li>
<li><p class="first">[strang:clean] <em>Clean State</em> [<code class="docutils literal notranslate"><span class="pre">clean_state()</span></code>]</p>
<p>This is done on <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<p>After these checks, we check the state for NaNs.</p>
</li>
<li><p class="first">[strang:radial] <em>Update radial data and center of mass for monopole gravity</em></p>
<p>These quantities are computed using <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</li>
<li><p class="first">[strang:newsource] <em>Correct the source terms with the n+1
contribution</em> [<code class="docutils literal notranslate"><span class="pre">construct_new_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_new_sources</span></code> ]</p>
<p>Previously we added <span class="math notranslate nohighlight">\(\Delta t\, \Sb(\Ub^\star)\)</span> to the state, when
we really want a time-centered approach,
<span class="math notranslate nohighlight">\((\Delta t/2)[\Sb(\Ub^\star + \Sb(\Ub^{n+1,(b)})]\)</span> . We fix that here.</p>
<p>We start by computing the source term vector <span class="math notranslate nohighlight">\(\Sb(\Ub^{n+1,(b)})\)</span>
using the updated state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span>. We then compute the
correction, <span class="math notranslate nohighlight">\((\Delta t/2)[\Sb(\Ub^{n+1,(b)}) - \Sb(\Ub^\star)]\)</span> to
add to <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span> to give us the properly time-centered source,
and the fully updated state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(c)}\)</span>. This correction is stored
in the new_sources MultiFab <a class="footnote-reference" href="#id7" id="id5">[2]</a>.</p>
<p>In the process of updating the sources, we update the temperature to
make it consistent with the new state.</p>
</li>
<li><p class="first"><em>React</em> <span class="math notranslate nohighlight">\(\Delta t/2\)</span> [<code class="docutils literal notranslate"><span class="pre">strang_react_second_half()</span></code>]</p>
<p>We do the final <span class="math notranslate nohighlight">\(\dt/2\)</span> reacting on the state, begining with <span class="math notranslate nohighlight">\(\Ub^{n+1,(c)}\)</span> to
give us the final state on this level, <span class="math notranslate nohighlight">\(\Ub^{n+1}\)</span>.</p>
<p>This is largely the same as <code class="docutils literal notranslate"><span class="pre">strang_react_first_half()</span></code>, but
it does not currently fill the reactions in the ghost cells.</p>
</li>
<li><p class="first">[strang:finalize] <em>Finalize</em> [<code class="docutils literal notranslate"><span class="pre">finalize_do_advance()</span></code>]</p>
<p>Finalize does the following:</p>
<ol class="arabic simple">
<li>for the momentum sources, we compute <span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, to use in the
source term prediction/extrapolation for the hydrodynamic
interface states during the next step.</li>
<li>If we are doing the hybrid momentum algorithm, then we sync up
the hybrid and linear momenta</li>
</ol>
</li>
</ol>
<p>A summary of which state is the input and which is updated for each of
these processes is presented below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="15%" />
<col width="29%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>step</em></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">S_old</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">Sborder</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">S_new</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><ol class="first last arabic simple">
<li>init</li>
</ol>
</td>
<td>input</td>
<td>updated</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="2">
<li>react</li>
</ol>
</td>
<td>&#160;</td>
<td>input / updated</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="3">
<li>old sources</li>
</ol>
</td>
<td>&#160;</td>
<td>input</td>
<td>updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="4">
<li>hydro</li>
</ol>
</td>
<td>&#160;</td>
<td>input</td>
<td>updated</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="5">
<li>clean</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="6">
<li>radial / center</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="7">
<li>correct sources</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="8">
<li>react</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="main-hydro-reaction-and-gravity-advancement-mol-w-strang-splitting">
<h3>Main Hydro, Reaction, and Gravity Advancement (MOL w/ Strang-splitting)<a class="headerlink" href="#main-hydro-reaction-and-gravity-advancement-mol-w-strang-splitting" title="Permalink to this headline">¶</a></h3>
<p>The handling of sources differs in the MOL integration, as compared to CTU.
Again, consider our system as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial\Ub}{\partial t} = -{\bf A}(\Ub) + \Rb(\Ub) + \Sb \, .\]</div>
<p>We will again use Strang splitting to discretize the
advection-reaction equations, but the hydro update will consist of <span class="math notranslate nohighlight">\(s\)</span>
stages. The update first does the reactions, as with CTU:</p>
<div class="math notranslate nohighlight">
\[\Ub^\star = \Ub^n + \frac{\dt}{2}\Rb(\Ub^n)\]</div>
<p>We then consider the hydro update discretized in space, but not time, written
as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \Ub}{\partial t} = -{\bf A}(\Ub) + \Sb(\Ub)\]</div>
<p>Using a Runge-Kutta (or similar) integrator, we write the update as:</p>
<div class="math notranslate nohighlight">
\[\Ub^{n+1,\star} = \Ub^\star + \dt \sum_{l=1}^s b_i {\bf k}_l\]</div>
<p>where <span class="math notranslate nohighlight">\(b_i\)</span> is the weight for stage <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(k_i\)</span> is the stage update:</p>
<div class="math notranslate nohighlight">
\[{\bf k}_l = -{\bf A}(\Ub_l) + \Sb(\Ub_l)\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\Ub_l = \Ub^\star  + \dt \sum_{m=1}^{l-1} a_{lm} {\bf k}_m\]</div>
<p>Finally, there is the last part of the reactions:</p>
<div class="math notranslate nohighlight">
\[\Ub^{n+1} = \Ub^{n+1,\star} + \frac{\dt}{2} \Rb(\Ub^{n+1,\star})\]</div>
<p>In contrast to the CTU method, the sources are treated together
with the advection here.</p>
<p>The time at the intermediate stages is evaluated as:</p>
<div class="math notranslate nohighlight">
\[t_l = c_l \dt\]</div>
<p>The integration coefficients are stored in the vectors
<code class="docutils literal notranslate"><span class="pre">a_mol</span></code>, <code class="docutils literal notranslate"><span class="pre">b_mol</span></code>, and <code class="docutils literal notranslate"><span class="pre">c_mol</span></code>, and the
stage updates are stored in the MultiFab <code class="docutils literal notranslate"><span class="pre">k_mol</span></code>.</p>
<p>Here is the single-level algorithm. We use the same notation
as in the CTU flowchart.</p>
<p>In the code, the objective is to evolve the state from the old time,
<code class="docutils literal notranslate"><span class="pre">S_old</span></code>, to the new time, <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<ol class="arabic">
<li><p class="first">[strang:init] <em>Initialize</em></p>
<p>In <code class="docutils literal notranslate"><span class="pre">initialize_do_advance()</span></code>, set the starting point for the stage’s integration:</p>
<ol class="arabic">
<li><p class="first">if <code class="docutils literal notranslate"><span class="pre">mol_iteration</span></code> = 0: initialize
<code class="docutils literal notranslate"><span class="pre">Sborder</span></code> from <code class="docutils literal notranslate"><span class="pre">S_old</span></code></p>
</li>
<li><p class="first">if <code class="docutils literal notranslate"><span class="pre">mol_iteration</span></code> &gt; 0: we need to create
the starting point for the current stage. We store this,
temporarily in the new-time slot (what we normally refer to as
<code class="docutils literal notranslate"><span class="pre">S_new</span></code>):</p>
<div class="math notranslate nohighlight">
\[\mathtt{S\_new}_\mathrm{iter} = \mathtt{Sburn} + \dt \sum_{l=0}^{\mathrm{iter}-1} a_{\mathrm{iter},l} \mathtt{k\_mol}_l\]</div>
<p>Then initialize <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> from <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</li>
</ol>
<p>Check for NaNs in the initial state, <code class="docutils literal notranslate"><span class="pre">S_old</span></code>.</p>
</li>
<li><p class="first"><em>React</em> <span class="math notranslate nohighlight">\(\Delta t/2\)</span> [<code class="docutils literal notranslate"><span class="pre">strang_react_first_half()</span></code> ]</p>
<p>This step is unchanged from the CTU version. At the end of this
step, <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> sees the effects of the reactions.</p>
<p>Each stage needs to build its starting point from this point, so we
store the effect of the burn in a new MultiFab, <code class="docutils literal notranslate"><span class="pre">Sburn</span></code>,
for use in the stage initialization.</p>
</li>
<li><p class="first">[strang:oldsource] <em>Construct sources from the current
stage’s state</em>
[<code class="docutils literal notranslate"><span class="pre">construct_old_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_old_sources()</span></code>]</p>
<p>The time level <span class="math notranslate nohighlight">\(n\)</span> sources are computed, and added to the
StateData <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code>. The sources are then applied
to the state after the burn, <span class="math notranslate nohighlight">\(\Ub^\star\)</span> with a full <span class="math notranslate nohighlight">\(\Delta t\)</span>
weighting (this will be corrected later). This produces the
intermediate state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(a)}\)</span>.</p>
<p>For full Poisson gravity, we solve for for gravity using:</p>
<div class="math notranslate nohighlight">
\[\gb^n = -\nabla\phi^n, \qquad
    \Delta\phi^n = 4\pi G\rho^n,\]</div>
</li>
<li><p class="first">[strang:hydro] <em>Construct the hydro update</em> [<code class="docutils literal notranslate"><span class="pre">construct_hydro_source()</span></code>]</p>
<p>The hydro update in the MOL branch will include both the advective
and source terms. In each stage, store in <code class="docutils literal notranslate"><span class="pre">k_mol[istage]</span></code> the righthand
side for the current stage.</p>
<p>In constructing the stage update, we use the source evaluated earlier,
and compute:</p>
<div class="math notranslate nohighlight">
\[\mathtt{k\_mol}_l = - \Ab(\Ub_l) + \Sb(\Ub_l)\]</div>
<p>Each call to <code class="docutils literal notranslate"><span class="pre">do_advance_mol</span></code> only computes this update for
a single stage. On the last stage, we compute the final update
as:</p>
<div class="math notranslate nohighlight">
\[\mathtt{S\_new} = \mathtt{Sburn} + \dt \sum_{l=0}^{\mathrm{n\_stages}-1} b_l \, \mathrm{k\_mol}_l\]</div>
</li>
<li><p class="first">[strang:clean] <em>Clean State</em> [<code class="docutils literal notranslate"><span class="pre">clean_state()</span></code>]</p>
<p>This is done on <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<p>After these checks, we check the state for NaNs.</p>
</li>
<li><p class="first"><em>React</em> <span class="math notranslate nohighlight">\(\Delta t/2\)</span> [<code class="docutils literal notranslate"><span class="pre">strang_react_second_half()</span></code>]</p>
<p>We do the final <span class="math notranslate nohighlight">\(\dt/2\)</span> reacting on the state, begining with <span class="math notranslate nohighlight">\(\Ub^{n+1,(c)}\)</span> to
give us the final state on this level, <span class="math notranslate nohighlight">\(\Ub^{n+1}\)</span>.</p>
<p>This is largely the same as <code class="docutils literal notranslate"><span class="pre">strang_react_first_half()</span></code>, but
it does not currently fill the reactions in the ghost cells.</p>
</li>
<li><p class="first">[strang:finalize] <em>Finalize</em> [<code class="docutils literal notranslate"><span class="pre">finalize_do_advance()</span></code>]</p>
<p>Finalize does the following:</p>
<ol class="arabic simple">
<li>for the momentum sources, we compute <span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, to use in the
source term prediction/extrapolation for the hydrodynamic
interface states during the next step.</li>
<li>If we are doing the hybrid momentum algorithm, then we sync up
the hybrid and linear momenta</li>
</ol>
</li>
</ol>
<p>A summary of which state is the input and which is updated for each of
these processes is presented below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="15%" />
<col width="29%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>step</em></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">S_old</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">Sborder</span></code></th>
<th class="head"><code class="docutils literal notranslate"><span class="pre">S_new</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><ol class="first last arabic simple">
<li>init</li>
</ol>
</td>
<td>input</td>
<td>updated</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="2">
<li>react</li>
</ol>
</td>
<td>&#160;</td>
<td>input / updated</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="3">
<li>old sources</li>
</ol>
</td>
<td>&#160;</td>
<td>input</td>
<td>updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="4">
<li>hydro</li>
</ol>
</td>
<td>&#160;</td>
<td>input</td>
<td>updated</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="5">
<li>clean</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="6">
<li>radial / center</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="7">
<li>correct sources</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="8">
<li>react</li>
</ol>
</td>
<td>&#160;</td>
<td>&#160;</td>
<td>input / updated</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="overview-of-a-single-step-with-sdc">
<h2>Overview of a single step (with SDC)<a class="headerlink" href="#overview-of-a-single-step-with-sdc" title="Permalink to this headline">¶</a></h2>
<p>We express our system as:</p>
<div class="math notranslate nohighlight">
\[\Ub_t = \mathcal{A}(\Ub) + \Rb(\Ub)\]</div>
<p>here <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the advective source, which includes both the
flux divergence and the hydrodynamic source terms (e.g. gravity):</p>
<div class="math notranslate nohighlight">
\[\mathcal{A}(\Ub) = -\nabla \cdot \Fb(\Ub) + \Sb\]</div>
<p>The SDC version of the main advance loop looks similar to the no-SDC
version, but includes an iteration loop over the hydro, gravity, and
reaction update. So the only difference happens in step 2 of the
flowchart outlined in §&nbsp;<a class="reference external" href="#flow:sec:nosdc">2</a>. In particular this
step now proceeds as:</p>
<ol class="arabic" start="2">
<li><p class="first"><em>Advancement</em></p>
<p>Loop <span class="math notranslate nohighlight">\(k\)</span> from 0 to <code class="docutils literal notranslate"><span class="pre">sdc_iters</span></code>, doing:</p>
<ol class="arabic">
<li><p class="first"><em>Hydrodynamics advance</em>: This is done through
do_advance—in SDC mode, this only updates the hydrodynamics,
including the non-reacting sources. However, in predicting the
interface states, we use an iteratively-lagged approximation to the
reaction source on the primitive variables, <span class="math notranslate nohighlight">\(\mathcal{I}_q^{k-1}\)</span>.</p>
<p>The result of this is an approximation to <span class="math notranslate nohighlight">\(\mathcal{A}(\Ub)\)</span>,
stored in <code class="docutils literal notranslate"><span class="pre">hydro_sources</span></code> (the flux divergence)
and <code class="docutils literal notranslate"><span class="pre">old_sources</span></code> and <code class="docutils literal notranslate"><span class="pre">new_sources</span></code>.</p>
</li>
<li><p class="first"><em>React</em>: Reactions are integrated with the advective
update as a source—this way the reactions see the
time-evolution due to advection as we integrate:</p>
<div class="math notranslate nohighlight">
\[\frac{d\Ub}{dt} = \left [ \mathcal{A}(\Ub) \right ]^{n+1/2} + \Rb(\Ub)\]</div>
<p>The advective source includes both the divergence of the fluxes
as well as the time-centered source terms. This is computed by
<code class="docutils literal notranslate"><span class="pre">sum_of_sources()</span></code> by summing over all source components
<code class="docutils literal notranslate"><span class="pre">hydro_source</span></code>, <code class="docutils literal notranslate"><span class="pre">old_sources</span></code>, and
<code class="docutils literal notranslate"><span class="pre">new_sources</span></code>.</p>
</li>
<li><p class="first"><em>Clean state</em>: This ensures that the thermodynamic state is
valid and consistent.</p>
</li>
<li><p class="first"><em>Construct reaction source terms</em>: Construct the change
in the primitive variables due only to reactions over the
timestep, <span class="math notranslate nohighlight">\(\mathcal{I}_q^{k}\)</span>. This will be used in the next
iteration.</p>
</li>
</ol>
</li>
</ol>
<p>Note that is it likely that some of the other updates (like any
non-advective auxiliary quantity updates) should be inside the SDC
loop, but presently they are only done at the end. Also note that the
radiation implicit update is not done as part of the SDC iterations.</p>
<div class="section" id="main-hydro-and-gravity-advancement-sdc">
<h3>Main Hydro and Gravity Advancement (SDC)<a class="headerlink" href="#main-hydro-and-gravity-advancement-sdc" title="Permalink to this headline">¶</a></h3>
<p>The evolution in do_advance is substantially different than the
Strang case. In particular, reactions are not evolved. Here we
summarize those differences.</p>
<ol class="arabic">
<li><p class="first"><em>Initialize</em> [<code class="docutils literal notranslate"><span class="pre">initialize_do_advance()</span></code>]</p>
<p>This is unchanged from step <a class="reference external" href="#strang:init">[strang:init]</a> in the Strang algorithm.</p>
</li>
<li><p class="first"><em>Construct time-level n sources and apply</em>
[<code class="docutils literal notranslate"><span class="pre">construct_old_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_old_sources()</span></code>]</p>
<p>This corresponds to step <a class="reference external" href="#strang:oldsource">[strang:oldsource]</a> in the Strang
algorithm. There are not differences compared to the Strang
algorithm, although we note, this only needs to be done for the first
SDC iteration in the advancement, since the old state does not change.</p>
</li>
<li><p class="first"><em>Construct the hydro update</em> [<code class="docutils literal notranslate"><span class="pre">construct_hydro_source()</span></code>]</p>
<p>This corresponds to step&nbsp;<a class="reference external" href="#strang:hydro">[strang:hydro]</a> in the Strang
algorithm. There are a few major differences with the Strang case:</p>
<ul class="simple">
<li>There is no need to extrapolate source terms to the half-time
for the prediction (the <code class="docutils literal notranslate"><span class="pre">castro.source_term_predictor</span></code>
parameter), since SDC provides a natural way to approximate the
time-centered source—we simply use the iteratively-lagged new-time
source.</li>
<li>The primitive variable source terms that are used for the
prediction include the contribution due to reactions (from the last
SDC iteration). This addition is done in
<code class="docutils literal notranslate"><span class="pre">construct_hydro_source()</span></code> after the source terms are
converted to primitive variables.</li>
</ul>
</li>
<li><p class="first"><em>Update radial data and center of mass for monopole gravity</em></p>
<p>This is the same as the Strang step&nbsp;<a class="reference external" href="#strang:radial">[strang:radial]</a></p>
</li>
<li><p class="first"><em>Clean State</em> [<code class="docutils literal notranslate"><span class="pre">clean_state()</span></code>]</p>
<p>This is the same as the Strang step&nbsp;<a class="reference external" href="#strang:clean">[strang:clean]</a></p>
</li>
<li><p class="first">[strang:newsource] <em>Correct the source terms with the n+1 contribution</em>
[<code class="docutils literal notranslate"><span class="pre">construct_new_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_new_sources</span></code> ]</p>
<p>This is the same as the Strang step&nbsp;<a class="reference external" href="#strang:newsource">[strang:newsource]</a></p>
</li>
<li><p class="first"><em>Finalize</em> [<code class="docutils literal notranslate"><span class="pre">finalize_do_advance()</span></code>]</p>
<p>This differs from Strang step&nbsp;<a class="reference external" href="#strang:finalize">[strang:finalize]</a> in that we do not
construct <span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, but instead store the total hydrodynamical source
term at the new time. As discussed above, this will be used in the
next iteration to approximate the time-centered source term.</p>
</li>
</ol>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Note: this functionality assumes that only the
coarse grid touches the physical boundary. It does not use
any use masks to prevent double counting if multiple levels
touch the boundary.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>The correction for gravity is slightly different since we directly compute the time-centered gravitational source term using the hydrodynamic fluxes.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="software.html" class="btn btn-neutral float-right" title="Software Design" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="runtime_parameters.html" class="btn btn-neutral" title="namespace: castro" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Castro development tem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}"}}})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>